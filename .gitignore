require 'pragmatic_segmenter'

def word_counter
	# Lists words, their frequency, and location based on sentences from given text doc.
	# Created 9/16/2015
	# Author: Christopher G Manna
	
	# setting new values
	h = Hash.new(0); i = 0;	alph = "a".ord; pot_sentences = []

	# Testing to make sure the arg after program name is a txt file that exists
	case 
	when ARGV[0].nil?
		puts "Please enter a filename following the program name."
		puts "Exitting Program"
		exit(0)
	when !(File.exist?(ARGV[0]))
		puts "Could not find file #{ARGV[0]}"
		puts "Exitting Program"
		exit(0)
	when ARGV[0].to_s.scan(/[.txt']/)
		# https://github.com/diasks2/pragmatic_segmenter
		# GitHub UN: diasks2
		txt = File.open(ARGV[0], "r+")
		ps = PragmaticSegmenter::Segmenter.new(text: txt.read)
		pot_sentences = ps.segment
		txt.close
	else
		puts "Something is wrong."
		puts "Exitting program"
		exit(0)
	end
	
	pot_sentences.map! {|elmt| elmt.downcase }
	arr = []
	pot_sentences.each { |sentence| arr << sentence.scan(/^\S*\.\S*$/)}#/[\w']+/)}
	.sort.each {|word| h[word] += 1 }#breakdown.split(/^\S*\.\S*$/)}} #
	#end
	#.sort.each {|elmt| h[elmt] +=1}
p	arr
=begin	
	#txt.read.downcase.scan(/[\w']+/).sort.each {|elmt| h[elmt] +=1}
		# finding word without gramatical interruption and sorting vals
		# finding frequency for each word that appears and storing in hash
	txt.close
	
	val = (h.keys.max_by(&:length)).length + 10
		# setting indent length for table formatting

	printf "%-#{val + 1}s %s\n","Word List","Frequency & Locations"
		# title of printed table, 
	h.each do |k, v| 
		str = "" # resetting alpha value so as not to include previous
		
		((i / 26)+1).times {str += (alph + (i % 26)).chr}
			# dynamically increase list alphabetically and roll over at end of alpha
		
		printf("%s. %-#{val - str.length}s{%s:loc(1), loc(2), etc}\n", str,k,v) 
			# dynamically create output table
		i += 1
			# increment through alpha
	end
=end
end
var = ""
